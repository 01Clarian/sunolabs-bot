// === IMPORTS ===
import TelegramBot from "node-telegram-bot-api";
import fs from "fs";
import express from "express";
import cors from "cors";
import rateLimit from "express-rate-limit";
import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  ComputeBudgetProgram,
  VersionedTransaction,
} from "@solana/web3.js";
import {
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createTransferInstruction,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import bs58 from "bs58";

// === TELEGRAM CONFIG ===
const token = process.env.BOT_TOKEN;
if (!token) throw new Error("BOT_TOKEN not set");

const bot = new TelegramBot(token, { polling: false });

// === Graceful shutdown ===
let isShuttingDown = false;

async function gracefulShutdown(signal) {
  if (isShuttingDown) return;
  isShuttingDown = true;
  console.log(`üßπ Graceful shutdown (${signal})...`);
  saveState();
  console.log("‚úÖ Shutdown complete");
  process.exit(0);
}

process.once("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.once("SIGINT", () => gracefulShutdown("SIGINT"));
process.on("unhandledRejection", (reason, promise) => {
  console.error("‚ö†Ô∏è Unhandled Rejection:", reason);
});

const CHANNEL = "sunolabs_submissions";
const MAIN_CHANNEL = "sunolabs";

// === SOLANA CONFIG ===
const RPC_URL = process.env.SOLANA_RPC_URL;
if (!RPC_URL) {
  throw new Error("‚ùå SOLANA_RPC_URL environment variable required!");
}
const connection = new Connection(RPC_URL, "confirmed");

// === WALLET ADDRESSES ===
const TREASURY = new PublicKey("98tf4zU5WhLmsCt1D4HQH5Ej9C5aFwCz8KQwykmKvDDQ");
const TRANS_FEE_WALLET = new PublicKey("CDfvckc6qBqBKaxXppPJrhkbZHHYvjVw2wAFjM38gX4B");
const TOKEN_MINT = new PublicKey("4vTeHaoJGvrKduJrxVmfgkjzDYPzD8BJJDv5Afempump");

const TREASURY_PRIVATE_KEY = process.env.BOT_PRIVATE_KEY
  ? Uint8Array.from(JSON.parse(process.env.BOT_PRIVATE_KEY))
  : null;
if (!TREASURY_PRIVATE_KEY) throw new Error("‚ùå BOT_PRIVATE_KEY missing!");
const TREASURY_KEYPAIR = Keypair.fromSecretKey(TREASURY_PRIVATE_KEY);

// === STATE ===
let treasurySUNO = 0;  // Competition pool in SUNO tokens
let transFeeCollected = 0;
let pendingPayments = [];
let participants = [];
let voters = [];
let phase = "submission";
let cycleStartTime = null;
let nextPhaseTime = null;

// === TIER CONFIGURATION ===
const TIERS = {
  BASIC: { 
    min: 0.01, 
    max: 0.049,
    retention: 0.50,
    multiplier: 1.0,
    name: "Basic",
    badge: "üéµ"
  },
  MID: { 
    min: 0.05, 
    max: 0.099,
    retention: 0.55,
    multiplier: 1.05,
    name: "Mid Tier",
    badge: "üíé"
  },
  HIGH: { 
    min: 0.10, 
    max: 0.499,
    retention: 0.60,
    multiplier: 1.10,
    name: "High Tier",
    badge: "üëë"
  },
  WHALE: { 
    min: 0.50,
    max: 999,
    retention: 0.65,
    multiplier: 1.15,
    name: "Whale",
    badge: "üêã"
  }
};

function getTier(amount) {
  if (amount >= TIERS.WHALE.min) return TIERS.WHALE;
  if (amount >= TIERS.HIGH.min) return TIERS.HIGH;
  if (amount >= TIERS.MID.min) return TIERS.MID;
  return TIERS.BASIC;
}

function getWhaleRetention(amount) {
  if (amount < 0.50) return 0.65;
  if (amount >= 5.00) return 0.75;
  return 0.65 + ((amount - 0.50) / 4.50) * 0.10;
}

function getWhaleMultiplier(amount) {
  if (amount < 0.50) return 1.15;
  if (amount >= 5.00) return 1.50;
  return 1.15 + ((amount - 0.50) / 4.50) * 0.35;
}

// === TRANSFER TOKENS TO RECIPIENT ===
async function transferTokensToRecipient(tokenAmount, recipientWallet) {
  try {
    console.log(`üì§ Initiating token transfer...`);
    
    const recipientPubkey = new PublicKey(recipientWallet);
    
    // Get treasury token account
    const treasuryTokenAccount = await getAssociatedTokenAddress(
      TOKEN_MINT,
      TREASURY_KEYPAIR.publicKey
    );
    
    // Get or create recipient token account
    const recipientTokenAccount = await getAssociatedTokenAddress(
      TOKEN_MINT,
      recipientPubkey
    );
    
    // Check if recipient ATA exists
    const recipientATA = await connection.getAccountInfo(recipientTokenAccount);
    
    const tx = new Transaction();
    
    // Create recipient ATA if needed
    if (!recipientATA) {
      console.log("üìù Creating recipient token account...");
      tx.add(
        createAssociatedTokenAccountInstruction(
          TREASURY_KEYPAIR.publicKey,
          recipientTokenAccount,
          recipientPubkey,
          TOKEN_MINT
        )
      );
    }
    
    // Add transfer instruction
    tx.add(
      createTransferInstruction(
        treasuryTokenAccount,
        recipientTokenAccount,
        TREASURY_KEYPAIR.publicKey,
        tokenAmount
      )
    );
    
    tx.feePayer = TREASURY_KEYPAIR.publicKey;
    const { blockhash } = await connection.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    
    console.log("‚úçÔ∏è Signing transfer transaction...");
    const sig = await connection.sendTransaction(tx, [TREASURY_KEYPAIR]);
    
    console.log(`üì§ Transfer sent: ${sig.substring(0, 8)}...`);
    console.log(`üîó https://solscan.io/tx/${sig}`);
    
    await connection.confirmTransaction(sig, "confirmed");
    
    console.log(`‚úÖ Transfer confirmed!`);
    
    return true;
    
  } catch (err) {
    console.error(`‚ùå Token transfer failed: ${err.message}`);
    console.error(err.stack);
    return false;
  }
}

// === CHECK IF TOKEN HAS BONDED ===
async function checkIfBonded() {
  try {
    console.log("üîç Checking if SUNO has graduated from pump.fun...");
    
    const PUMP_PROGRAM = new PublicKey("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P");
    
    // Derive bonding curve PDA
    const [bondingCurve] = PublicKey.findProgramAddressSync(
      [Buffer.from("bonding-curve"), TOKEN_MINT.toBuffer()],
      PUMP_PROGRAM
    );
    
    const accountInfo = await connection.getAccountInfo(bondingCurve);
    
    if (!accountInfo) {
      console.log("‚úÖ Token has graduated to Raydium! Using Jupiter...");
      return true;
    }
    
    // Check if bonding curve is complete
    const data = accountInfo.data;
    const complete = data[8];
    
    if (complete === 1) {
      console.log("‚úÖ Bonding curve complete! Token graduated. Using Jupiter...");
      return true;
    }
    
    console.log("üìä Token still on pump.fun bonding curve. Using PumpPortal API...");
    return false;
    
  } catch (err) {
    console.error(`‚ö†Ô∏è Bond check error: ${err.message}. Defaulting to Jupiter...`);
    return true;
  }
}

// === PUMP.FUN BUY (Using PumpPortal API) ===
async function buyOnPumpFun(solAmount) {
  try {
    console.log(`üöÄ Starting pump.fun buy with PumpPortal API: ${solAmount.toFixed(4)} SOL`);
    console.log(`üìç Buying to treasury, will split SUNO after...`);
    
    // Get transaction from PumpPortal
    console.log("üìä Getting PumpPortal transaction...");
    const quoteResponse = await fetch(`https://pumpportal.fun/api/trade-local`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        publicKey: TREASURY_KEYPAIR.publicKey.toBase58(),
        action: "buy",
        mint: TOKEN_MINT.toBase58(),
        denominatedInSol: "true",
        amount: solAmount,
        slippage: 10,
        priorityFee: 0.0001,
        pool: "pump"
      })
    });
    
    if (!quoteResponse.ok) {
      const errorText = await quoteResponse.text();
      throw new Error(`PumpPortal request failed: ${quoteResponse.status} - ${errorText}`);
    }
    
    // PumpPortal returns raw binary transaction data (not base64!)
    const txData = await quoteResponse.arrayBuffer();
    console.log(`‚úÖ Got transaction data (${txData.byteLength} bytes)`);
    
    // Deserialize and sign transaction
    console.log("üîì Deserializing transaction...");
    const tx = VersionedTransaction.deserialize(new Uint8Array(txData));
    tx.sign([TREASURY_KEYPAIR]);
    
    // Send transaction
    console.log("üì§ Sending buy transaction...");
    const sig = await connection.sendRawTransaction(tx.serialize(), {
      skipPreflight: false,
      preflightCommitment: 'confirmed',
      maxRetries: 3
    });
    
    console.log(`üì§ Transaction sent: ${sig.substring(0, 8)}...`);
    console.log(`üîó https://solscan.io/tx/${sig}`);
    console.log("‚è≥ Confirming transaction...");
    
    await connection.confirmTransaction(sig, "confirmed");
    
    console.log(`‚úÖ Pump.fun buy complete!`);
    
    // Wait for balance update
    await new Promise(r => setTimeout(r, 3000));
    
    // Get treasury token account
    const treasuryTokenAccount = await getAssociatedTokenAddress(
      TOKEN_MINT,
      TREASURY_KEYPAIR.publicKey
    );
    
    // Get tokens bought
    const balance = await connection.getTokenAccountBalance(treasuryTokenAccount);
    const receivedTokens = parseInt(balance.value.amount);
    
    console.log(`ü™ô Treasury received ${receivedTokens.toLocaleString()} SUNO tokens (will split next)`);
    
    return receivedTokens;
    
  } catch (err) {
    console.error(`‚ùå Pump.fun buy failed: ${err.message}`);
    console.error(err.stack);
    throw err;
  }
}

// === JUPITER SWAP ===
async function buyOnJupiter(solAmount) {
  try {
    console.log(`ü™ê Starting Jupiter swap: ${solAmount.toFixed(4)} SOL ‚Üí SUNO`);
    console.log(`üìç Buying to treasury, will split SUNO after...`);
    
    const lamports = Math.floor(solAmount * 1e9);
    
    // Get treasury's token account (where tokens will go)
    const treasuryTokenAccount = await getAssociatedTokenAddress(
      TOKEN_MINT,
      TREASURY_KEYPAIR.publicKey
    );
    
    console.log(`üìç Treasury token account: ${treasuryTokenAccount.toBase58().substring(0, 8)}...`);
    
    // Get quote from Jupiter
    console.log("üìä Getting Jupiter quote...");
    const quoteResponse = await fetch(
      `https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=${TOKEN_MINT.toBase58()}&amount=${lamports}&slippageBps=500`
    );
    
    if (!quoteResponse.ok) {
      throw new Error(`Jupiter quote request failed: ${quoteResponse.status} ${quoteResponse.statusText}`);
    }
    
    const quoteData = await quoteResponse.json();
    
    if (!quoteData || quoteData.error) {
      throw new Error(`Quote failed: ${quoteData?.error || 'Unknown error'}`);
    }
    
    const outAmount = parseInt(quoteData.outAmount);
    console.log(`üíé Quote received: ${outAmount.toLocaleString()} SUNO (${(outAmount / 1e6).toFixed(2)}M tokens)`);
    
    // Get swap transaction (to treasury's token account)
    console.log("üî® Building swap transaction...");
    const swapResponse = await fetch('https://quote-api.jup.ag/v6/swap', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        quoteResponse: quoteData,
        userPublicKey: TREASURY_KEYPAIR.publicKey.toBase58(),
        destinationTokenAccount: treasuryTokenAccount.toBase58(),
        wrapAndUnwrapSol: true,
        dynamicComputeUnitLimit: true,
        prioritizationFeeLamports: {
          priorityLevelWithMaxLamports: {
            maxLamports: 100000,
            priorityLevel: "high"
          }
        }
      })
    });
    
    if (!swapResponse.ok) {
      throw new Error(`Jupiter swap request failed: ${swapResponse.status} ${swapResponse.statusText}`);
    }
    
    const swapData = await swapResponse.json();
    
    if (!swapData.swapTransaction) {
      throw new Error('No swap transaction returned from Jupiter');
    }
    
    console.log("‚úçÔ∏è Signing and sending transaction...");
    
    // Deserialize and sign
    const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(swapTransactionBuf);
    transaction.sign([TREASURY_KEYPAIR]);
    
    const rawTransaction = transaction.serialize();
    const sig = await connection.sendRawTransaction(rawTransaction, {
      skipPreflight: false,
      preflightCommitment: 'confirmed',
      maxRetries: 3
    });
    
    console.log(`üì§ Transaction sent: ${sig.substring(0, 8)}...`);
    console.log(`üîó https://solscan.io/tx/${sig}`);
    console.log("‚è≥ Confirming transaction...");
    
    await connection.confirmTransaction(sig, 'confirmed');
    
    console.log(`‚úÖ Jupiter swap complete!`);
    console.log(`ü™ô Treasury received ~${outAmount.toLocaleString()} SUNO tokens (will split next)`);
    
    return outAmount;
    
  } catch (err) {
    console.error(`‚ùå Jupiter swap failed: ${err.message}`);
    console.error(err.stack);
    throw err;
  }
}

// === MARKET INTEGRATION (Auto-detect pump.fun or Jupiter) ===
async function buySUNOOnMarket(solAmount) {
  try {
    console.log(`\nüîÑ ========== BUYING SUNO ==========`);
    console.log(`üí∞ Amount: ${solAmount.toFixed(4)} SOL`);
    console.log(`üìç Buying to treasury (will split after)`);
    
    const isBonded = await checkIfBonded();
    
    let sunoAmount;
    if (isBonded) {
      // Use Jupiter
      console.log("üìä Using Jupiter (token graduated)...");
      sunoAmount = await buyOnJupiter(solAmount);
    } else {
      // Try pump.fun, fallback to Jupiter if it fails
      console.log("üìä Trying PumpPortal (token on bonding curve)...");
      try {
        sunoAmount = await buyOnPumpFun(solAmount);
      } catch (pumpError) {
        console.error(`‚ö†Ô∏è PumpPortal failed: ${pumpError.message}`);
        console.log("üîÑ Falling back to Jupiter...");
        sunoAmount = await buyOnJupiter(solAmount);
      }
    }
    
    console.log(`‚úÖ Purchase complete! ${sunoAmount.toLocaleString()} SUNO now in treasury`);
    console.log(`üîÑ ===================================\n`);
    return sunoAmount;
    
  } catch (err) {
    console.error(`‚ùå Market buy failed: ${err.message}`);
    console.error(err.stack);
    throw err;
  }
}

// === STATE PERSISTENCE ===
const SAVE_FILE = fs.existsSync("/data")
  ? "/data/submissions.json"
  : "./submissions.json";

function saveState() {
  try {
    fs.writeFileSync(
      SAVE_FILE,
      JSON.stringify({
        participants,
        voters,
        phase,
        cycleStartTime,
        nextPhaseTime,
        treasurySUNO,
        transFeeCollected,
        pendingPayments
      }, null, 2)
    );
  } catch (err) {
    console.error("‚ö†Ô∏è Failed to save state:", err.message);
  }
}

function loadState() {
  if (!fs.existsSync(SAVE_FILE)) return;
  try {
    const d = JSON.parse(fs.readFileSync(SAVE_FILE));
    participants = d.participants || [];
    voters = d.voters || [];
    phase = d.phase || "submission";
    cycleStartTime = d.cycleStartTime || null;
    nextPhaseTime = d.nextPhaseTime || null;
    treasurySUNO = d.treasurySUNO || 0;
    transFeeCollected = d.transFeeCollected || 0;
    pendingPayments = d.pendingPayments || [];
    console.log(`üìÇ State restored ‚Äî ${participants.length} participants, phase: ${phase}`);
  } catch (e) {
    console.error("‚ö†Ô∏è Failed to load:", e.message);
  }
}

// === EXPRESS SERVER ===
const app = express();
app.use(cors());
app.use(express.json({ limit: '10kb' })); // Limit request size
const PORT = process.env.PORT || 10000;

// === RATE LIMITING ===
const paymentLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 10, // 10 payment confirmations per minute per IP
  message: { error: '‚ö†Ô∏è Too many payment attempts, please wait' },
  standardHeaders: true,
  legacyHeaders: false,
});

const generalLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute per IP
  message: { error: '‚ö†Ô∏è Too many requests, please try again later' },
  standardHeaders: true,
  legacyHeaders: false,
});

app.get("/", generalLimiter, async (_, res) => {
  const uploaders = participants.filter(p => p.choice === "upload" && p.paid).length;
  const voteOnly = voters.length;
  
  res.json({
    status: "‚úÖ SunoLabs Buy SUNO System Live",
    mode: "webhook",
    phase,
    uploaders,
    voteOnly,
    treasury: treasurySUNO.toLocaleString() + " SUNO",
    transFees: transFeeCollected.toFixed(4) + " SOL",
    uptime: process.uptime()
  });
});

app.post(`/webhook/${token}`, generalLimiter, (req, res) => {
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

// === PAYMENT CONFIRMATION ===
app.post("/confirm-payment", paymentLimiter, async (req, res) => {
  console.log("\n==============================================");
  console.log("üîî /confirm-payment ENDPOINT HIT!");
  console.log("üì¶ Request body:", JSON.stringify(req.body, null, 2));
  console.log("==============================================\n");
  
  try {
    const { signature, reference, userId, amount, senderWallet } = req.body;
    
    // === VALIDATION ===
    console.log("üîç Validating parameters...");
    if (!userId || !reference || !senderWallet) {
      console.log("‚ùå MISSING PARAMETERS!");
      console.warn("‚ö†Ô∏è Missing params:", req.body);
      return res.status(400).json({ error: "Missing required fields" });
    }
    
    // Validate amount is reasonable
    const amountNum = parseFloat(amount);
    if (isNaN(amountNum) || amountNum < 0.001 || amountNum > 100) {
      console.log("‚ùå INVALID AMOUNT:", amount);
      return res.status(400).json({ error: "Invalid amount (must be 0.001-100 SOL)" });
    }
    
    // Validate wallet address
    try {
      new PublicKey(senderWallet);
    } catch (e) {
      console.log("‚ùå INVALID WALLET:", senderWallet);
      return res.status(400).json({ error: "Invalid wallet address" });
    }
    
    console.log("‚úÖ Parameters validated!");

    const userKey = String(userId);
    
    console.log(`\nüí≥ ========== PAYMENT RECEIVED ==========`);
    console.log(`üí∞ Amount: ${amountNum} SOL`);
    console.log(`üë§ User: ${userKey}`);
    console.log(`üëõ Wallet: ${senderWallet.substring(0, 8)}...`);
    console.log(`üìù Reference: ${reference.substring(0, 8)}...`);
    console.log(`=====================================\n`);

    // Check for duplicates
    let existing = pendingPayments.find((p) => p.reference === reference);
    if (existing && existing.confirmed) {
      console.log("‚ö†Ô∏è Payment already processed - returning success");
      return res.json({ ok: true, message: "Already processed" });
    }

    if (existing) {
      existing.confirmed = true;
    } else {
      pendingPayments.push({
        userId: userKey,
        reference,
        confirmed: true,
      });
    }

    // === PAYMENT SPLIT ===
    console.log("üí∞ Calculating payment split...");
    const transFee = amountNum * 0.10;
    const remainingSOL = amountNum * 0.90;
    
    const tier = getTier(amountNum);
    let retention = tier.retention;
    let multiplier = tier.multiplier;
    
    if (tier === TIERS.WHALE) {
      retention = getWhaleRetention(amountNum);
      multiplier = getWhaleMultiplier(amountNum);
    }
    
    console.log(`\nüí∞ ========== PAYMENT SPLIT ==========`);
    console.log(`üè¶ Trans Fee (10%): ${transFee.toFixed(4)} SOL ‚Üí Fee wallet`);
    console.log(`üíé Buy SUNO with: ${remainingSOL.toFixed(4)} SOL`);
    console.log(`üìä Then split SUNO tokens:`);
    console.log(`   üë§ User gets: ${(retention * 100).toFixed(0)}% of SUNO`);
    console.log(`   üèÜ Competition pool: ${((1 - retention) * 100).toFixed(0)}% of SUNO`);
    console.log(`${tier.badge} Tier: ${tier.name} | ${multiplier}x multiplier`);
    console.log(`=====================================\n`);

    // === SEND TRANS FEE ===
    console.log("üí∏ Sending trans fee...");
    try {
      await sendSOLPayout(TRANS_FEE_WALLET.toBase58(), transFee, "Trans fee");
      transFeeCollected += transFee;
      console.log("‚úÖ Trans fee sent successfully");
    } catch (err) {
      console.error(`‚ùå Trans fee failed: ${err.message}`);
    }

    // === BUY SUNO WITH ALL REMAINING SOL ===
    let totalSUNO = 0;
    console.log("\nü™ô Starting SUNO purchase with ALL remaining SOL...");
    try {
      totalSUNO = await buySUNOOnMarket(remainingSOL);
      console.log(`\n‚úÖ SUNO purchase SUCCESS: ${totalSUNO.toLocaleString()} tokens total`);
    } catch (err) {
      console.error(`\n‚ùå SUNO purchase FAILED: ${err.message}`);
      console.error(err.stack);
    }

    // === CHECK IF PURCHASE WAS SUCCESSFUL ===
    if (totalSUNO === 0 || !totalSUNO) {
      console.log("‚ö†Ô∏è SUNO purchase returned 0 tokens - notifying user of failure");
      
      try {
        await bot.sendMessage(
          userId,
          `‚ùå Purchase Failed!\n\n‚ö†Ô∏è We received your ${amountNum} SOL payment, but the SUNO token purchase failed.\n\nüîÑ Please contact support or try again.\n\nError: Token purchase returned 0 tokens.`
        );
      } catch (e) {
        console.error("‚ö†Ô∏è Failed to send error message:", e.message);
      }
      
      console.log("‚úÖ Error notification sent - returning error to client\n");
      return res.json({ ok: false, error: "SUNO purchase failed", sunoAmount: 0 });
    }

    // === SPLIT SUNO TOKENS ===
    const userSUNO = Math.floor(totalSUNO * retention);
    const competitionSUNO = totalSUNO - userSUNO;
    
    console.log(`\nüíé ========== SUNO TOKEN SPLIT ==========`);
    console.log(`ü™ô Total SUNO bought: ${totalSUNO.toLocaleString()}`);
    console.log(`üë§ User gets: ${userSUNO.toLocaleString()} SUNO (${(retention * 100).toFixed(0)}%)`);
    console.log(`üèÜ Competition pool: ${competitionSUNO.toLocaleString()} SUNO (${((1 - retention) * 100).toFixed(0)}%)`);
    console.log(`========================================\n`);

    // === TRANSFER USER'S PORTION ===
    console.log(`üì§ Transferring ${userSUNO.toLocaleString()} SUNO to user...`);
    const transferSuccess = await transferTokensToRecipient(userSUNO, senderWallet);
    
    if (!transferSuccess) {
      console.error("‚ùå Transfer failed!");
      try {
        await bot.sendMessage(
          userId,
          `‚ùå Transfer Failed!\n\n‚ö†Ô∏è SUNO purchase succeeded but transfer to your wallet failed.\n\nPlease contact support.`
        );
      } catch (e) {}
      return res.json({ ok: false, error: "Transfer failed", sunoAmount: 0 });
    }

    console.log(`‚úÖ ${userSUNO.toLocaleString()} SUNO ‚Üí ${senderWallet.substring(0, 8)}...`);

    // === ADD COMPETITION POOL TO TREASURY ===
    treasurySUNO += competitionSUNO;
    console.log(`\nüè¶ Treasury updated: +${competitionSUNO.toLocaleString()} SUNO (Total: ${treasurySUNO.toLocaleString()} SUNO)`);

    // === SAVE USER DATA ===
    const userData = {
      userId: userKey,
      wallet: senderWallet,
      amount: amountNum,
      sunoReceived: userSUNO,
      tier: tier.name,
      tierBadge: tier.badge,
      retention: (retention * 100).toFixed(0) + "%",
      multiplier,
      paid: true,
      timestamp: Date.now()
    };

    // === REGISTER USER BASED ON PRE-SELECTED CHOICE ===
    const payment = pendingPayments.find(p => p.reference === reference);
    const userChoice = payment?.choice || "vote"; // Default to vote if somehow missing

    if (userChoice === "upload") {
      // Register as competitor
      if (!payment.track) {
        console.log("‚ö†Ô∏è User chose upload but didn't send audio - defaulting to vote");
        voters.push({
          ...userData,
          choice: "vote",
          votedFor: null
        });
        
        try {
          await bot.sendMessage(
            userId,
            `‚úÖ Payment complete!\n\nü™ô ${userSUNO.toLocaleString()} SUNO sent!\n${tier.badge} ${tier.name} tier (${(retention * 100).toFixed(0)}% retention)\nüí∞ ${multiplier}x prize multiplier\n\n‚ö†Ô∏è No audio found - registered as voter.\nüó≥Ô∏è Vote during voting phase to earn rewards!`
          );
        } catch (e) {
          console.error("‚ö†Ô∏è DM error:", e.message);
        }
      } else {
        participants.push({
          ...userData,
          choice: "upload",
          user: payment.user,
          track: payment.track,
          title: payment.title,
          votes: 0,
          voters: []
        });
        
        try {
          await bot.sendMessage(
            userId,
            `‚úÖ Track entered!\n\nü™ô ${userSUNO.toLocaleString()} SUNO sent!\n${tier.badge} ${tier.name} tier (${(retention * 100).toFixed(0)}% retention)\nüí∞ ${multiplier}x prize multiplier\n\nüéµ Your track "${payment.title}" is in the competition!\nüçÄ Good luck!`
          );
        } catch (e) {
          console.error("‚ö†Ô∏è DM error:", e.message);
        }
      }
    } else {
      // Register as voter
      voters.push({
        ...userData,
        choice: "vote",
        votedFor: null
      });
      
      try {
        await bot.sendMessage(
          userId,
          `‚úÖ Registered as voter!\n\nü™ô ${userSUNO.toLocaleString()} SUNO sent!\n${tier.badge} ${tier.name} tier (${(retention * 100).toFixed(0)}% retention)\nüí∞ ${multiplier}x prize multiplier\n\nüó≥Ô∏è Vote during voting phase to earn rewards!`
        );
      } catch (e) {
        console.error("‚ö†Ô∏è DM error:", e.message);
      }
    }

    // Mark as paid
    if (payment) {
      payment.paid = true;
      payment.userData = userData;
    }

    saveState();

    console.log("‚úÖ Payment processing complete - returning success to client\n");
    res.json({ ok: true, sunoAmount: userSUNO });
  } catch (err) {
    console.error(`\nüí• FATAL ERROR in confirm-payment: ${err.message}`);
    console.error(err.stack);
    res.status(500).json({ error: "Internal error" });
  }
});

// === SOL PAYOUT (for trans fees) ===
async function sendSOLPayout(destination, amountSOL, reason = "payout") {
  try {
    const lamports = Math.floor(amountSOL * 1e9);
    if (lamports <= 0) return;
    
    const tx = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: TREASURY_KEYPAIR.publicKey,
        toPubkey: new PublicKey(destination),
        lamports,
      })
    );
    tx.feePayer = TREASURY_KEYPAIR.publicKey;
    tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;

    const sig = await connection.sendTransaction(tx, [TREASURY_KEYPAIR]);
    await connection.confirmTransaction(sig, "confirmed");
    console.log(`üí∏ ${reason}: ${amountSOL.toFixed(4)} SOL ‚Üí ${destination.substring(0, 8)}...`);
  } catch (err) {
    console.error(`‚ö†Ô∏è ${reason} failed: ${err.message}`);
  }
}

// === SUNO TOKEN PAYOUT ===
async function sendSUNOPayout(destination, amountSUNO, reason = "payout") {
  try {
    console.log(`üí∏ ${reason}: ${amountSUNO.toLocaleString()} SUNO ‚Üí ${destination.substring(0, 8)}...`);
    
    const success = await transferTokensToRecipient(amountSUNO, destination);
    
    if (!success) {
      console.error(`‚ö†Ô∏è ${reason} failed!`);
    }
    
  } catch (err) {
    console.error(`‚ö†Ô∏è ${reason} failed: ${err.message}`);
  }
}

// === START NEW CYCLE ===
async function startNewCycle() {
  console.log("üîÑ Starting new cycle...");
  
  phase = "submission";
  cycleStartTime = Date.now();
  nextPhaseTime = cycleStartTime + 5 * 60 * 1000;
  saveState();

  const botUsername = process.env.BOT_USERNAME || 'sunolabs_bot';
  
  console.log(`üé¨ NEW CYCLE: Submission phase (5 min), Prize pool: ${treasurySUNO.toLocaleString()} SUNO`);
  
  try {
    const botMention = botUsername.startsWith('@') ? botUsername : `@${botUsername}`;
    
    await bot.sendMessage(
      `@${MAIN_CHANNEL}`,
      `üé¨ NEW ROUND STARTED!\n\nüí∞ Prize Pool: ${treasurySUNO.toLocaleString()} SUNO\n‚è∞ 5 minutes to join!\n\nüéÆ How to Play:\n1Ô∏è‚É£ Open ${botMention}\n2Ô∏è‚É£ Type /start\n3Ô∏è‚É£ Choose your path:\n   üéµ Upload track & compete for prizes\n   üó≥Ô∏è Vote only & earn rewards\n4Ô∏è‚É£ Buy SUNO tokens (0.01 SOL minimum)\n5Ô∏è‚É£ Win SUNO prizes! üèÜ\n\nüöÄ Start now!`
    );
    console.log("‚úÖ Posted cycle start to main channel");
  } catch (err) {
    console.error("‚ùå Failed to announce:", err.message);
  }

  setTimeout(() => startVoting(), 5 * 60 * 1000);
}

// === VOTING ===
async function startVoting() {
  console.log(`üìã Starting voting ‚Äî Uploaders: ${participants.filter(p => p.choice === "upload" && p.paid).length}`);
  
  const uploaders = participants.filter((p) => p.choice === "upload" && p.paid);
  
  if (!uploaders.length) {
    console.log("üö´ No uploads this round");
    
    try {
      await bot.sendMessage(
        `@${MAIN_CHANNEL}`,
        `‚è∞ No entries this round\nNew round in 1 minute!`
      );
    } catch {}
    
    phase = "cooldown";
    saveState();
    setTimeout(() => startNewCycle(), 60 * 1000);
    return;
  }

  phase = "voting";
  nextPhaseTime = Date.now() + 5 * 60 * 1000;
  saveState();

  try {
    await bot.sendMessage(
      `@${MAIN_CHANNEL}`,
      `üó≥Ô∏è VOTING STARTED!\n\nüí∞ Prize Pool: ${treasurySUNO.toLocaleString()} SUNO\n‚è∞ 5 minutes to vote!\n\nüî• Listen to tracks & vote for your favorite!\nüìç Vote here: https://t.me/${CHANNEL}\n\nüèÜ Winners get 80% of prize pool\nüí∞ Voters who pick the winner share 20%!`
    );
  } catch {}

  try {
    await bot.sendMessage(
      `@${CHANNEL}`,
      `üó≥Ô∏è VOTING STARTED!\n\nüí∞ Prize Pool: ${treasurySUNO.toLocaleString()} SUNO\n‚è∞ 5 minutes to vote!\n\nüéµ Listen to each track below\nüî• Vote for your favorite!\n\nüèÜ Top 5 tracks win prizes\nüíé Vote for the winner = earn rewards!`
    );

    for (const p of uploaders) {
      await bot.sendAudio(`@${CHANNEL}`, p.track, {
        caption: `${p.tierBadge} ${p.user} ‚Äî ${p.title}\nüî• 0`,
        reply_markup: {
          inline_keyboard: [[{ text: "üî• Vote", callback_data: `vote_${p.userId}` }]]
        }
      });
      await new Promise((r) => setTimeout(r, 1200));
    }
    console.log(`‚úÖ Posted ${uploaders.length} tracks`);
  } catch (err) {
    console.error("‚ùå Voting failed:", err.message);
  }

  setTimeout(() => announceWinners(), 5 * 60 * 1000);
}

// === ANNOUNCE WINNERS ===
async function announceWinners() {
  console.log(`üèÜ Announcing winners...`);
  
  phase = "cooldown";
  saveState();
  
  const uploaders = participants.filter((p) => p.choice === "upload" && p.paid);
  
  if (!uploaders.length) {
    console.log("üö´ No uploads");
    participants = [];
    voters = [];
    treasurySUNO = 0;
    pendingPayments = [];
    saveState();
    setTimeout(() => startNewCycle(), 60 * 1000);
    return;
  }

  const sorted = [...uploaders].sort((a, b) => b.votes - a.votes);
  const weights = [0.40, 0.25, 0.20, 0.10, 0.05];
  const numWinners = Math.min(5, sorted.length);
  
  const prizePool = Math.floor(treasurySUNO * 0.80);
  const voterPool = treasurySUNO - prizePool;
  
  let resultsMsg = `üèÜ Competition Results üèÜ\nüí∞ Prize Pool: ${prizePool.toLocaleString()} SUNO\n\n`;
  
  for (let i = 0; i < numWinners; i++) {
    const w = sorted[i];
    const baseAmt = Math.floor(prizePool * weights[i]);
    const finalAmt = Math.floor(baseAmt * w.multiplier);
    
    resultsMsg += `#${i + 1} ${w.tierBadge} ${w.user} ‚Äî ${w.votes}üî• ‚Äî ${finalAmt.toLocaleString()} SUNO\n`;
    
    if (w.wallet && finalAmt > 0) {
      await sendSUNOPayout(w.wallet, finalAmt, `Prize #${i + 1}`);
      
      try {
        await bot.sendMessage(w.userId, `üéâ You won ${finalAmt.toLocaleString()} SUNO! Check your wallet! üéä`);
      } catch {}
    }
  }

  const winner = sorted[0];
  const winnerVoters = voters.filter(v => v.votedFor === winner.userId);
  
  if (winnerVoters.length > 0 && voterPool > 0) {
    const totalVoterAmount = winnerVoters.reduce((sum, v) => sum + v.amount, 0);
    
    resultsMsg += `\nüó≥Ô∏è Voter Rewards: ${voterPool.toLocaleString()} SUNO\n`;
    
    for (const v of winnerVoters) {
      const share = Math.floor((v.amount / totalVoterAmount) * voterPool);
      
      if (share > 0) {
        await sendSUNOPayout(v.wallet, share, "Voter reward");
        
        try {
          await bot.sendMessage(v.userId, `üéâ You voted for the winner!\nReward: ${share.toLocaleString()} SUNO üí∞`);
        } catch {}
      }
    }
    
    resultsMsg += `‚úÖ ${winnerVoters.length} voter(s) rewarded!`;
  }

  try {
    await bot.sendMessage(`@${CHANNEL}`, resultsMsg);
    await bot.sendMessage(
      `@${MAIN_CHANNEL}`,
      `üéâ WINNER: ${winner.tierBadge} ${winner.user}\nüí∞ Won ${Math.floor(prizePool * 0.40 * winner.multiplier).toLocaleString()} SUNO!\n\nüèÜ See full results in @${CHANNEL}\n‚è∞ Next round starts in 1 minute!\n\nüéÆ Type /start in the bot to play!`
    );
  } catch {}

  console.log(`üí∞ Distributed ${treasurySUNO.toLocaleString()} SUNO`);
  participants = [];
  voters = [];
  treasurySUNO = 0;
  pendingPayments = [];
  saveState();
  
  setTimeout(() => startNewCycle(), 60 * 1000);
}

// === TELEGRAM HANDLERS ===
bot.onText(/\/start|play/i, async (msg) => {
  const user = msg.from.username ? `@${msg.from.username}` : msg.from.first_name || "Unknown";
  const userId = String(msg.from.id);

  if (phase !== "submission") {
    await bot.sendMessage(userId, `‚ö†Ô∏è ${phase} phase active. Wait for next round!`);
    return;
  }

  const now = Date.now();
  let timeMessage = "";
  
  if (cycleStartTime) {
    const submissionEndTime = cycleStartTime + (5 * 60 * 1000);
    const timeRemaining = Math.max(0, submissionEndTime - now);
    const minutesLeft = Math.ceil(timeRemaining / 60000);
    timeMessage = `\n‚è∞ ${minutesLeft} minute${minutesLeft !== 1 ? 's' : ''} left to join!`;
  }

  await bot.sendMessage(
    userId,
    `üéÆ Welcome to SunoLabs Competition!\n\nüí∞ Prize Pool: ${treasurySUNO.toLocaleString()} SUNO${timeMessage}\n\nüéØ Choose your path:`,
    {
      reply_markup: {
        inline_keyboard: [
          [{ text: "üéµ Upload Track & Compete", callback_data: `start_upload_${userId}` }],
          [{ text: "üó≥Ô∏è Vote Only & Earn", callback_data: `start_vote_${userId}` }]
        ]
      }
    }
  );
});

bot.on("message", async (msg) => {
  // Ignore non-private chats
  if (msg.chat.type !== "private") return;

  const userId = String(msg.from.id);
  
  // Handle audio files (track uploads)
  if (msg.audio) {
    const user = msg.from.username ? `@${msg.from.username}` : msg.from.first_name || "Unknown";

    if (phase !== "submission") {
      await bot.sendMessage(userId, `‚ö†Ô∏è ${phase} phase active. Type /start when a new round begins!`);
      return;
    }

    // Check if user has chosen upload path
    const uploadChoice = pendingPayments.find(p => p.userId === userId && p.choice === "upload" && !p.paid);
    
    if (!uploadChoice) {
      await bot.sendMessage(
        userId,
        `‚ö†Ô∏è Please type /start and choose "Upload Track" first!`
      );
      return;
    }

    // Save the track
    uploadChoice.track = msg.audio.file_id;
    uploadChoice.title = msg.audio.file_name || "Untitled";
    uploadChoice.user = user;
    saveState();

    const reference = uploadChoice.reference;
    const redirectLink = `https://sunolabs-redirect.onrender.com/pay?recipient=${TREASURY.toBase58()}&amount=0.01&reference=${reference}&userId=${userId}`;

    await bot.sendMessage(
      userId,
      `üéß Track received!\n\nü™ô Now buy SUNO tokens to enter the competition!`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: "ü™ô Buy SUNO & Enter Competition", url: redirectLink }]
          ]
        }
      }
    );
    return;
  }
  
  // Handle /start command (already handled above, but just in case)
  if (msg.text?.match(/^\/start|^play$/i)) {
    return; // Already handled by onText
  }
  
  // Catch-all for any other text message
  if (msg.text) {
    const now = Date.now();
    let phaseInfo = "";
    
    if (phase === "submission" && cycleStartTime) {
      const submissionEndTime = cycleStartTime + (5 * 60 * 1000);
      const timeRemaining = Math.max(0, submissionEndTime - now);
      const minutesLeft = Math.ceil(timeRemaining / 60000);
      phaseInfo = `\n\n‚è∞ Current round ends in ${minutesLeft} minute${minutesLeft !== 1 ? 's' : ''}!`;
    } else if (phase === "voting") {
      phaseInfo = `\n\nüó≥Ô∏è Voting is currently active! Check @${CHANNEL}`;
    } else if (phase === "cooldown") {
      phaseInfo = `\n\n‚è∞ New round starting soon!`;
    }
    
    await bot.sendMessage(
      userId,
      `üëã Hi! Welcome to SunoLabs Competition!\n\nüéÆ To play, type:\n/start\n\nThen choose:\nüéµ Upload track & compete for SUNO prizes\nüó≥Ô∏è Vote only & earn SUNO rewards${phaseInfo}`
    );
  }
});

bot.on("callback_query", async (q) => {
  try {
    // Handle initial choice (before payment)
    if (q.data.startsWith("start_")) {
      const [, action, userKey] = q.data.split("_");
      
      if (phase !== "submission") {
        await bot.answerCallbackQuery(q.id, { text: "‚ö†Ô∏è Submission phase ended!" });
        return;
      }

      const reference = Keypair.generate().publicKey;
      const redirectLink = `https://sunolabs-redirect.onrender.com/pay?recipient=${TREASURY.toBase58()}&amount=0.01&reference=${reference.toBase58()}&userId=${userKey}`;

      if (action === "upload") {
        // User chose to upload track
        pendingPayments.push({
          userId: userKey,
          choice: "upload",
          reference: reference.toBase58(),
          confirmed: false,
          paid: false
        });
        saveState();

        await bot.answerCallbackQuery(q.id, { text: "‚úÖ Upload mode selected!" });
        await bot.sendMessage(
          userKey,
          `üéµ Upload Track & Compete!\n\nüì§ Send me your audio file now.`
        );

      } else if (action === "vote") {
        // User chose to vote only
        pendingPayments.push({
          userId: userKey,
          choice: "vote",
          reference: reference.toBase58(),
          confirmed: false,
          paid: false
        });
        saveState();

        await bot.answerCallbackQuery(q.id, { text: "‚úÖ Vote mode selected!" });
        await bot.sendMessage(
          userKey,
          `üó≥Ô∏è Vote Only & Earn!\n\nü™ô Buy SUNO tokens to participate!`,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "ü™ô Buy SUNO & Join as Voter", url: redirectLink }]
              ]
            }
          }
        );
      }
      
      return;
    }

    // Handle voting on tracks
    if (q.data.startsWith("vote_")) {
      const [, userIdStr] = q.data.split("_");
      const targetId = String(userIdStr);
      const voterId = String(q.from.id);
      
      const entry = participants.find((p) => String(p.userId) === targetId);
      
      if (!entry) {
        await bot.answerCallbackQuery(q.id, { text: "‚ö†Ô∏è Not found" });
        return;
      }

      if (entry.voters.includes(voterId)) {
        await bot.answerCallbackQuery(q.id, { text: "‚ö†Ô∏è Already voted" });
        return;
      }

      entry.votes++;
      entry.voters.push(voterId);
      
      const voter = voters.find(v => v.userId === voterId);
      if (voter) {
        voter.votedFor = targetId;
      }
      
      saveState();

      try {
        await bot.editMessageCaption(`${entry.tierBadge} ${entry.user} ‚Äî ${entry.title}\nüî• ${entry.votes}`, {
          chat_id: q.message.chat.id,
          message_id: q.message.message_id,
          reply_markup: {
            inline_keyboard: [[{ text: "üî• Vote", callback_data: `vote_${entry.userId}` }]]
          }
        });
      } catch {}
      
      await bot.answerCallbackQuery(q.id, { text: "‚úÖ Voted!" });
    }
  } catch (err) {
    console.error("‚ö†Ô∏è Callback error:", err.message);
  }
});

// === STARTUP ===
app.listen(PORT, async () => {
  console.log(`üåê SunoLabs Buy SUNO Bot on port ${PORT}`);
  
  loadState();
  
  const webhookUrl = `https://sunolabs-bot.onrender.com/webhook/${token}`;
  try {
    await bot.deleteWebHook();
    await new Promise(resolve => setTimeout(resolve, 1000));
    await bot.setWebHook(webhookUrl);
    console.log("‚úÖ Webhook set");
  } catch (err) {
    console.error("‚ùå Webhook failed:", err.message);
  }
  
  const now = Date.now();
  
  if (!cycleStartTime || phase === "cooldown") {
    console.log("üöÄ Starting new cycle in 3 seconds...");
    setTimeout(() => startNewCycle(), 3000);
  } else if (phase === "submission") {
    const timeLeft = (cycleStartTime + 5 * 60 * 1000) - now;
    if (timeLeft <= 0) {
      setTimeout(() => startVoting(), 1000);
    } else {
      console.log(`‚è∞ Resuming submission (${Math.ceil(timeLeft / 60000)}m left)`);
      setTimeout(() => startVoting(), timeLeft);
    }
  } else if (phase === "voting") {
    const timeLeft = nextPhaseTime - now;
    if (timeLeft <= 0) {
      setTimeout(() => announceWinners(), 1000);
    } else {
      console.log(`‚è∞ Resuming voting (${Math.ceil(timeLeft / 60000)}m left)`);
      setTimeout(() => announceWinners(), timeLeft);
    }
  }
});

setInterval(() => {
  console.log(`‚è∞ Phase: ${phase} | Uploaders: ${participants.filter(p => p.choice === "upload").length} | Voters: ${voters.length}`);
}, 30000);

console.log("‚úÖ SunoLabs Buy SUNO Bot initialized...");
